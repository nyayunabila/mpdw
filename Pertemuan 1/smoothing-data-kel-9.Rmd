
---
title: "Pertemuan 1 - Pemulusan"
author: Nyayu Azzahra Nabila
date: "2025-05-21"
output:
  pdf_document:
    toc: true
    toc_depth: '3'
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    theme: united
editor_options:
  markdown:
  wrap: 72
---


```{r}
library("forecast")
library("graphics")
library("TTR")
library("TSA")
```

## Impor Data

```{r}
library(rio)
data_fmcg <- import("https://raw.githubusercontent.com/nyayunabila/mpdw/refs/heads/main/Pertemuan%201/data-kelompok-9-mpdw.csv")
```

## Subset Data
```{r}
#ambil baris 101-200
subset_data <- data_fmcg[101:200, 2]

#gabungkan data.frame dengan subset_data
data101 <- data.frame(periode = 1:100, daily_revenue = subset_data)
```

## Eksplorasi Data

```{r}
View(data101)
str(data101)
dim(data101)
```
Mengubah data agar terbaca sebagai data deret waktu dengan fungsi `ts()` .

```{r}
data101.ts <- ts(data101$daily_revenue)
```

Menampilkan ringkasan data

```{r}
summary(data101.ts)
```
Membuat plot data deret waktu

```{r}
ts.plot(data101.ts, xlab="Time Period ", ylab="daily_revenue", 
        main = "Time Series Plot")
points(data101.ts)
```

Kalau dilihat dari plotnya, plotnya tidak konstan, trennya tidak naik ataupun turun, dan tidak terlihat plot data musiman. Sehingga, saya akan mencoba menggunakan SMA dan SES.

## Pembagian Data

Pembagian data latih dan data uji dilakukan dengan perbandingan 80% data latih dan 20% data uji.

```{r}
#membagi data latih dan data uji
training101<- data101[1:80,]
testing101<- data101[81:100,]
train101.ts <- ts(training101$daily_revenue)
test101.ts <- ts(testing101$daily_revenue)
```

## Eksplorasi Data

```{r}
#Eksplorasi dengan GGPLOT
library(ggplot2)
ggplot() + 
  geom_line(data = training101, aes(x = periode, y = daily_revenue, col = "Data Latih")) +
  geom_line(data = testing101, aes(x = periode, y = daily_revenue, col = "Data Uji")) +
  labs(x = "date", y = "daily revenue", color = "Legend") +
  scale_colour_manual(name="Keterangan:", breaks = c("Data Latih", "Data Uji"),
                      values = c("blue", "red")) + 
  theme_bw() + theme(legend.position = "bottom",
                     plot.caption = element_text(hjust=0.5, size=12))
```


## Single Moving Average & Double Moving Average

### Single Moving Average (SMA)

n=4

```{r}
data101.sma<-SMA(train101.ts, n=4)
data101.sma
```
Data pemulusan pada periode ke-t selanjutnya digunakan sebagai nilai peramalan pada periode ke t+1 sehingga hasil peramalan 1 periode kedepan adalah sebagai berikut.

```{r}
data101.ramal<-c(NA,data101.sma)
data101.ramal #forecast 1 periode ke depan
```
Selanjutnya akan dilakukan peramalan sejumlah data uji yaitu 20 periode. Pada metode SMA, hasil peramalan 20 periode ke depan akan bernilai sama dengan hasil peramalan 1 periode kedepan. Dalam hal ini akan dilakukan pengguabungan data aktual train, data hasil pemulusan dan data hasil ramalan 20 periode kedepan.

```{r}
data101.gab<-cbind(aktual=c(train101.ts,rep(NA,20)),pemulusan=c(data101.sma,rep(NA,20)),ramalan=c(data101.ramal,rep(data101.ramal[length(data101.ramal)],19)))
data101.gab #forecast 20 periode ke depan
```
Adapun plot data deret waktu dari hasil peramalan yang dilakukan adalah sebagai berikut.

```{r}
ts.plot(data101.ts, xlab="Time Period ", ylab="Daily Revenue", main= "SMA N=4 Data Daily Revenue")
points(data101.ts)
lines(data101.gab[,2],col="green",lwd=2)
lines(data101.gab[,3],col="red",lwd=2)
legend("topleft",c("data aktual","data pemulusan","data peramalan"), lty=8, col=c("black","green","red"), cex=0.5)
```

Selanjutnya perhitungan akurasi dilakukan dengan ukuran akurasi *Sum Squares Error* (SSE), *Mean Square Error* (MSE) dan *Mean Absolute Percentage Error* (MAPE). Perhitungan akurasi dilakukan baik pada data latih maupun pada data uji.

```{r}
#Menghitung nilai keakuratan data latih
error101_train.sma = train101.ts-data101.ramal[1:length(train101.ts)]
SSE101_train.sma = sum(error101_train.sma[5:length(train101.ts)]^2)
MSE101_train.sma = mean(error101_train.sma[5:length(train101.ts)]^2)
MAPE101_train.sma = mean(abs((error101_train.sma[5:length(train101.ts)]/train101.ts[5:length(train101.ts)])*100))

akurasi101_train.sma <- matrix(c(SSE101_train.sma, MSE101_train.sma, MAPE101_train.sma))
row.names(akurasi101_train.sma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi101_train.sma) <- c("Akurasi m = 4")
akurasi101_train.sma
```

Dalam hal ini nilai MAPE data latih pada metode pemulusan SMA lebih dari 50% yaitu 69% artinya prediksi tidak akurat.

```{r}
#Menghitung nilai keakuratan data uji
error101_test.sma = test101.ts-data101.gab[81:100,3]
SSE101_test.sma = sum(error101_test.sma^2)
MSE101_test.sma = mean(error101_test.sma^2)
MAPE101_test.sma = mean(abs((error101_test.sma/test101.ts*100)))

akurasi101_test.sma <- matrix(c(SSE101_test.sma, MSE101_test.sma, MAPE101_test.sma))
row.names(akurasi101_test.sma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi101_test.sma) <- c("Akurasi m = 4")
akurasi101_test.sma
```

Perhitungan akurasi menggunakan data latih menghasilkan nilai MAPE yang lebih dari 20% sehingga nilai akurasi artinya prediksi tidak akurat.

Saya penasaran bagaimana jika kita ubah nilai n pada metode SMA menjadi 6, maka hasilnya adalah sebagai berikut.

n=6

```{r}
data101.sma<-SMA(train101.ts, n=6)
data101.sma

data101.ramal<-c(NA,data101.sma)
data101.ramal #forecast 1 periode ke depan

data101.gab<-cbind(aktual=c(train101.ts,rep(NA,20)),pemulusan=c(data101.sma,rep(NA,20)),ramalan=c(data101.ramal,rep(data101.ramal[length(data101.ramal)],19)))
data101.gab #forecast 20 periode ke depan

ts.plot(data101.ts, xlab="Time Period ", ylab="Daily Revenue", main= "SMA N=6 Data Daily Revenue")
points(data101.ts)
lines(data101.gab[,2],col="green",lwd=2)
lines(data101.gab[,3],col="red",lwd=2)
legend("topleft",c("data aktual","data pemulusan","data peramalan"), lty=8, col=c("black","green","red"), cex=0.5)

#Menghitung nilai keakuratan data latih
error101_train.sma = train101.ts-data101.ramal[1:length(train101.ts)]
SSE101_train.sma = sum(error101_train.sma[7:length(train101.ts)]^2)
MSE101_train.sma = mean(error101_train.sma[7:length(train101.ts)]^2)
MAPE101_train.sma = mean(abs((error101_train.sma[7:length(train101.ts)]/train101.ts[7:length(train101.ts)])*100))

akurasi101_train.sma <- matrix(c(SSE101_train.sma, MSE101_train.sma, MAPE101_train.sma))
row.names(akurasi101_train.sma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi101_train.sma) <- c("Akurasi m = 6")
akurasi101_train.sma

#Menghitung nilai keakuratan data uji
error101_test.sma = test101.ts-data101.gab[81:100,3]
SSE101_test.sma = sum(error101_test.sma^2)
MSE101_test.sma = mean(error101_test.sma^2)
MAPE101_test.sma = mean(abs((error101_test.sma/test101.ts*100)))

akurasi101_test.sma <- matrix(c(SSE101_test.sma, MSE101_test.sma, MAPE101_test.sma))
row.names(akurasi101_test.sma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi101_test.sma) <- c("Akurasi m = 6")
akurasi101_test.sma

```

Pada n = 6, nilai MAPE data latih pada metode pemulusan SMA lebih dari 50% yaitu 66% artinya prediksi tidak akurat. Sedangkan nilai MAPE data uji pada metode pemulusan SMA lebih dari 20% yaitu 37% artinya prediksi tidak akurat. Ternyata walau nilai n yang lebih besar menghasilkan nilai MAPE yang lebih kecil akan tetapi tetap saja nilai MAPE yang dihasilkan masih di atas 20% sehingga prediksi tidak akurat.


Kita akan coba dengan metode DMA 

### Double Moving Average (DMA)

```{r}
dma <- SMA(data101.sma, n = 4)
At <- 2*data101.sma - dma
Bt <- 2/ (4-1)*(data101.sma - dma)
data101.dma<- At+Bt
data101.ramal2<- c(NA, data101.dma)

t = 1:20
f = c()

for (i in t) {
  f[i] = At[length(At)] + Bt[length(Bt)]*(i)
}

data101.gab2 <- cbind(aktual = c(train101.ts,rep(NA,20)), pemulusan1 = c(data101.sma,rep(NA,20)),pemulusan2 = c(data101.dma, rep(NA,20)),At = c(At, rep(NA,20)), Bt = c(Bt,rep(NA,20)),ramalan = c(data101.ramal2, f[-1]))
data101.gab2
```

Hasil pemulusan menggunakan metode DMA divisualisasikan sebagai berikut

```{r}
ts.plot(data101.ts, xlab="Time Period ", ylab="Daily Revenue", main= "DMA N=4 Data Sales")
points(data101.ts)
lines(data101.gab2[,3],col="green",lwd=2)
lines(data101.gab2[,6],col="red",lwd=2)
legend("topleft",c("data aktual","data pemulusan","data peramalan"), lty=8, col=c("black","green","red"), cex=0.8)

```

Selanjutnya perhitungan akurasi dilakukan baik pada data latih maupun data uji. Perhitungan akurasi dilakukan dengan ukuran akurasi SSE, MSE dan MAPE.

```{r}
#Menghitung nilai keakuratan data latih
error101_train.dma = train101.ts-data101.ramal2[1:length(train101.ts)]
SSE101_train.dma = sum(error101_train.dma[20:length(train101.ts)]^2)
MSE101_train.dma = mean(error101_train.dma[20:length(train101.ts)]^2)
MAPE101_train.dma = mean(abs((error101_train.dma[20:length(train101.ts)]/train101.ts[20:length(train101.ts)])*100))

akurasi101_train.dma <- matrix(c(SSE101_train.dma, MSE101_train.dma, MAPE101_train.dma))
row.names(akurasi101_train.dma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi101_train.dma) <- c("Akurasi m = 4")
akurasi101_train.dma
```
Perhitungan akurasi pada data latih menggunakan nilai MAPE menghasilkan nilai MAPE lebih dari 50% yaitu 78%, artinya prediksi tidak akurat.

```{r}
#Menghitung nilai keakuratan data uji
error101_test.dma = test101.ts-data101.gab2[81:100,6]
SSE101_test.dma = sum(error101_test.dma^2)
MSE101_test.dma = mean(error101_test.dma^2)
MAPE101_test.dma = mean(abs((error101_test.dma/test101.ts*100)))

akurasi101_test.dma <- matrix(c(SSE101_test.dma, MSE101_test.dma, MAPE101_test.dma))
row.names(akurasi101_test.dma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi101_test.dma) <- c("Akurasi m = 2")
akurasi101_test.dma
```

Dari hasil perhitungan akurasi pada data uji menghasilkan MAPE yang sangat besar yaitu 234 persen pada data uji, artinya prediksi tidak akurat.

Pada metode SMA dan DMA, nilai MAPE yang dihasilkan sangat besar yaitu > 20% artinya prediksi tidak akurat. Sehingga, kita akan mencoba cara lainnya yaitu metode SES dan DES 

## Single Exponential Smoothing & Double Exponential Smoothing

### SES

Nilai parameter $\alpha$ dari kedua fungsi dapat dioptimalkan menyesuaikan dari *error*-nya paling minimumnya. Caranya adalah dengan membuat parameter $\alpha =$ `NULL` .

```{r}
#SES
ses101.opt <- ses(train101.ts, h = 20, alpha = NULL)
plot(ses101.opt)
ses101.opt

#Lamda Optimum Holt Winter
sesopt101<- HoltWinters(train101.ts, gamma = FALSE, beta = FALSE,alpha = NULL)
sesopt101
plot(sesopt101)

#ramalan
ramalanopt101<- forecast(sesopt101, h=20)
ramalanopt101
```

Selanjutnya akan dilakukan perhitungan akurasi pada data latih maupun data uji dengan ukuran akurasi SSE, MSE dan MAPE.

```{r}
accuracy(ramalanopt101,testing101$daily_revenue)
```
Pada metode SES, nilai MAPE yang dihasilkan juga cukup tinggi yaitu di atas 50% tepatnya pada angka 68% pada data latih dan 25% pada data uji, yang artinya prediksi kurang akurat, sehingga saya akan mencoba metode DES. 


### DES


```{r}
#Lamda dan gamma optimum
des101.opt<- HoltWinters(train101.ts, gamma = FALSE)
des101.opt
plot(des101.opt)

#ramalan
ramalandesopt101<- forecast(des101.opt, h=20)
ramalandesopt101
```


Selanjutnya akan dilakukan perhitungan akurasi pada data latih maupun data uji dengan ukuran akurasi SSE, MSE dan MAPE.

```{r}
accuracy(ramalandesopt101,testing101$daily_revenue)
```
Nilai MAPE pada DES juga sangat tinggi > 50% tepatnya 82% pada data latih dan 138% pada data uji artinya, prediksi kurang akurat.

## Kesimpulan
Pada dataset ini, metode smoothing sederhana (SMA dan SES) menghasilkan MAPE > 20%, yang menandakan prediksi kurang akurat. Oleh karena itu, diperlukan metode forecasting lain yang lebih mampu menangkap pola dataset. 

